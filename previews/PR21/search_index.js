var documenterSearchIndex = {"docs":
[{"location":"tutorials/qp/#Quadratic-Programs","page":"Quadratic Programs","title":"Quadratic Programs","text":"A quadratic program (QP) has a positive semidefinite Hessian Q:\n\nminimize    ½ yᵀQy - cᵀy\nsubject to   Ay ≥ b\n             Gy  = d","category":"section"},{"location":"tutorials/qp/#Example:-Projection-onto-the-Simplex","page":"Quadratic Programs","title":"Example: Projection onto the Simplex","text":"Project the point c = [1, 2, 3, 4, 5] onto the probability simplex {y : y ≥ 0, ∑yᵢ = 1}:\n\nusing ConicIP, SparseArrays, LinearAlgebra\n\nn = 5\nQ = sparse(1.0I, n, n)\nc = reshape(collect(1.0:n), :, 1)\n\n# Nonnegativity constraints: y ≥ 0\nA = sparse(1.0I, n, n)\nb = zeros(n, 1)\ncone_dims = [(\"R\", n)]\n\n# Simplex constraint: sum(y) = 1\nG = ones(1, n)\nd = ones(1, 1)\n\nsol = conicIP(Q, Q * c, A, b, cone_dims, G, d;\n              verbose=false, optTol=1e-7)\nsol.status\n\nround.(sol.y, digits=4)\n\nThe solution concentrates weight on the largest components of c, as expected for the nearest point on the simplex.","category":"section"},{"location":"tutorials/qp/#Convergence-Information","page":"Quadratic Programs","title":"Convergence Information","text":"The Solution struct reports convergence diagnostics:\n\nprFeas – primal feasibility: residual of Ay ≥ b and Gy = d\nduFeas – dual feasibility: residual of the KKT stationarity condition\nmuFeas – complementarity: residual of the complementary slackness condition\npobj, dobj – primal and dual objective values\n\n(prFeas=sol.prFeas, duFeas=sol.duFeas, muFeas=sol.muFeas, pobj=round(sol.pobj, digits=6), dobj=round(sol.dobj, digits=6))\n\nAt optimality, pobj ≈ dobj and all residuals are below the specified tolerance (optTol).","category":"section"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/#Requirements","page":"Installation","title":"Requirements","text":"Julia 1.10 or later","category":"section"},{"location":"installation/#Installing-ConicIP.jl","page":"Installation","title":"Installing ConicIP.jl","text":"ConicIP.jl is not yet registered in the Julia General registry. Install it directly from GitHub:\n\nusing Pkg\nPkg.add(url=\"https://github.com/MPF-Optimization-Laboratory/ConicIP.jl\")","category":"section"},{"location":"installation/#Verification","page":"Installation","title":"Verification","text":"After installation, verify that the package loads correctly:\n\nusing ConicIP","category":"section"},{"location":"installation/#Optional:-JuMP-Integration","page":"Installation","title":"Optional: JuMP Integration","text":"To use ConicIP as a JuMP solver, install JuMP as well:\n\nusing Pkg\nPkg.add(\"JuMP\")\n\nThen create a model with:\n\nusing JuMP, ConicIP\nmodel = Model(ConicIP.Optimizer)\n\nSee the JuMP Integration page for details.","category":"section"},{"location":"tutorials/lp/#Linear-Programs","page":"Linear Programs","title":"Linear Programs","text":"A linear program (LP) is a special case of the ConicIP problem formulation with Q = 0:\n\nminimize    -cᵀy\nsubject to   Ay ≥ b\n             Gy  = d","category":"section"},{"location":"tutorials/lp/#Example:-LP-with-Equality-and-Inequality-Constraints","page":"Linear Programs","title":"Example: LP with Equality and Inequality Constraints","text":"Solve a small LP with nonnegativity and an equality constraint:\n\nminimize    -2y₁ - 3y₂ - y₃ - y₄ - y₅\nsubject to   y₁ + y₂ + y₃ + y₄ + y₅ = 4\n             y ≥ 0\n\nusing ConicIP, SparseArrays, LinearAlgebra\n\nn = 5\nQ = spzeros(n, n)\nc = reshape([2.0, 3.0, 1.0, 1.0, 1.0], :, 1)\n\n# Nonnegativity: y ≥ 0\nA = sparse(1.0I, n, n)\nb = zeros(n, 1)\ncone_dims = [(\"R\", n)]\n\n# Equality constraint: sum(y) = 4\nG = ones(1, n)\nd = reshape([4.0], 1, 1)\n\nsol = conicIP(Q, c, A, b, cone_dims, G, d; verbose=false)\nsol.status\n\nround.(sol.y, digits=4)\n\nThe optimal solution puts all weight on the variable with the largest objective coefficient (y₂ = 4).","category":"section"},{"location":"tutorials/lp/#Reading-Primal-and-Dual-Solutions","page":"Linear Programs","title":"Reading Primal and Dual Solutions","text":"The dual variables sol.v give the shadow prices for the inequality constraints, and sol.w gives the dual for the equality constraint:\n\nround.(sol.v, digits=4)\n\nround.(sol.w, digits=4)\n\nThe primal and dual objective values should be equal at optimality:\n\n(pobj=round(sol.pobj, digits=6), dobj=round(sol.dobj, digits=6))","category":"section"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Solver","page":"API Reference","title":"Solver","text":"","category":"section"},{"location":"api/#Solution","page":"API Reference","title":"Solution","text":"","category":"section"},{"location":"api/#JuMP-/-MathOptInterface","page":"API Reference","title":"JuMP / MathOptInterface","text":"","category":"section"},{"location":"api/#Block-Diagonal-Matrices","page":"API Reference","title":"Block Diagonal Matrices","text":"","category":"section"},{"location":"api/#KKT-Solvers","page":"API Reference","title":"KKT Solvers","text":"","category":"section"},{"location":"api/#Utilities","page":"API Reference","title":"Utilities","text":"","category":"section"},{"location":"api/#Internal","page":"API Reference","title":"Internal","text":"These functions are implementation details and not part of the public API.","category":"section"},{"location":"api/#ConicIP.conicIP","page":"API Reference","title":"ConicIP.conicIP","text":"conicIP(Q, c, A, b, conedims, G, d;   solve3x3gen = solve3x3gensparse,   optTol = 1e-5,   DTB = 0.01,   verbose = true,   maxRefinementSteps = 3,   maxIters = 100,   cache_nestodd = false,   refinementThreshold = optTol/1e7)\n\nInterior point solver for the system\n\nminimize    ½yᵀQy - cᵀy\ns.t         Ay >= b\n            Gy  = d\n\nQ,c,A,b,G,d are matrices (c,b,d are NOT vectors)\n\ncone_dims is an array of tuples (Cone Type, Dimension)\n\ne.g. [(\"R\",2),(\"Q\",4)] means\n(y₁, y₂)          in  R+\n(y₃, y₄, y₅, y₆)  in  Q\n\nSDP Cones are NOT supported and purely experimental at this point.\n\nThe parameter solve3x3gen allows the passing of a custom solver for the KKT System, as follows\n\njulia> L = solve3x3gen(F,F⁻ᵀ,Q,A,G)\n\nThen this\n\njulia> (a,b,c) = L(y,w,v)\n\nsolves the system\n┌             ┐ ┌   ┐   ┌   ┐\n│ Q   G'  -A' │ │ a │ = │ y │\n│ G           │ │ b │   │ w │\n│ A       FᵀF │ │ c │   │ v │\n└             ┘ └   ┘   └   ┘\n\nWe can also wrap a 2x2 solver using pivot3gen(solve2x2gen) The 2x2 solves the system\n\njulia> L = solve2x2gen(F,F⁻ᵀ,Q,A,G)\n\nThen this\n\njulia> (a,b) = L(y,w)\n\nsolves the system\n\n┌                     ┐ ┌   ┐   ┌   ┐\n│ Q + Aᵀinv(FᵀF)A  G' │ │ a │ = │ y │\n│ G                   │ │ b │   │ w │\n└                     ┘ └   ┘   └   ┘\n\n\n\n\n\n","category":"function"},{"location":"api/#ConicIP.preprocess_conicIP","page":"API Reference","title":"ConicIP.preprocess_conicIP","text":"ConicIP with preprocessing to ensure the following rank constraints\n\nPrimal equailty constraints : Gx = d Rank condition              : rank(G) = size(G,1)\n\nDual equality constraints   : [ Q A' G'] = c Rank condition              : rank([Q A' G']) = size(Q,1)\n\n\n\n\n\n","category":"function"},{"location":"api/#ConicIP.Solution","page":"API Reference","title":"ConicIP.Solution","text":"Solution\n\nReturn type of conicIP and preprocess_conicIP.\n\nFields\n\ny::Matrix – primal variables\nw::Matrix – dual variables for equality constraints (Gy = d)\nv::Matrix – dual variables for inequality constraints (Ay ≥_K b)\nstatus::Symbol – :Optimal, :Infeasible, :Unbounded, :Abandoned, or :Error\nIter::Integer – number of interior-point iterations\nMu::Real – final complementarity gap parameter\nprFeas::Real – primal feasibility residual\nduFeas::Real – dual feasibility residual\nmuFeas::Real – complementarity residual\npobj::Real – primal objective value\ndobj::Real – dual objective value\n\n\n\n\n\n","category":"type"},{"location":"api/#ConicIP.Optimizer","page":"API Reference","title":"ConicIP.Optimizer","text":"Optimizer(; verbose=false, optTol=1e-6, maxIters=100)\n\nMathOptInterface optimizer wrapping the ConicIP interior-point solver. Use as a JuMP solver via Model(ConicIP.Optimizer).\n\nKeyword Arguments\n\nverbose::Bool – print solver iterations (default: false)\noptTol::Float64 – optimality tolerance (default: 1e-6)\nmaxIters::Int – maximum iterations (default: 100)\n\nSupported Constraints\n\nVector: Zeros, Nonnegatives, Nonpositives, SecondOrderCone, PositiveSemidefiniteConeTriangle\nScalar: EqualTo, GreaterThan, LessThan\n\n\n\n\n\n","category":"type"},{"location":"api/#ConicIP.Block","page":"API Reference","title":"ConicIP.Block","text":"Block(size::Int)\nBlock(Blk::Vector)\n\nBlock diagonal matrix type. Each diagonal block can be a different matrix type (Diagonal, SymWoodbury, VecCongurance, or dense Matrix).\n\nUsed internally to represent the Nesterov-Todd scaling matrix, where each block corresponds to a cone in the cone specification.\n\nSupports arithmetic (*, +, -, inv, adjoint, ^), conversion to sparse and Matrix, and block-wise function application via broadcastf.\n\nIndexing\n\nB[i] returns the i-th diagonal block\nB[i] = M sets the i-th diagonal block\n\n\n\n\n\n","category":"type"},{"location":"api/#ConicIP.block_idx","page":"API Reference","title":"ConicIP.block_idx","text":"block_idx(A::Block)\n\nReturn a vector of UnitRange{Int} giving the row/column index ranges for each diagonal block of A.\n\n\n\n\n\n","category":"function"},{"location":"api/#ConicIP.broadcastf","page":"API Reference","title":"ConicIP.broadcastf","text":"broadcastf(op, A::Block)\nbroadcastf(op, A::Block, B::Block)\nbroadcastf(op, A::Block, x::Union{Vector,Matrix})\n\nApply function op block-wise to the diagonal blocks of A (and optionally B or the corresponding segments of x).\n\n\n\n\n\n","category":"function"},{"location":"api/#ConicIP.kktsolver_qr","page":"API Reference","title":"ConicIP.kktsolver_qr","text":"Solves the 3x3 system\n\n┌             ┐ ┌    ┐   ┌   ┐\n│ Q   G'  -A' │ │ y' │ = │ y │\n│ G           │ │ w' │   │ w │\n│ A       FᵀF │ │ v' │   │ v │\n└             ┘ └    ┘   └   ┘\n\nby the double QR method described in CVXOPT http://www.seas.ucla.edu/~vandenbe/publications/coneprog.pdf section 10.2\n\n\n\n\n\n","category":"function"},{"location":"api/#ConicIP.kktsolver_sparse","page":"API Reference","title":"ConicIP.kktsolver_sparse","text":"Solves the 3x3 system\n\n┌             ┐ ┌    ┐   ┌   ┐\n│ Q   G'  -A' │ │ y' │ = │ y │\n│ G           │ │ w' │   │ w │\n│ A       FᵀF │ │ v' │   │ v │\n└             ┘ └    ┘   └   ┘\n\nBy lifting the large diagonal plus rank 3 blocks of FᵀF\n\nIntelligently chooses between solve3x3gensparselift and solve3x3gensparsedense by approximating the number of non-zeros in both and choosing the form with more sparsity. The former is better for large second order cones, while the latter is better if the constraints are the product of many small cones.\n\n\n\n\n\n","category":"function"},{"location":"api/#ConicIP.kktsolver_2x2","page":"API Reference","title":"ConicIP.kktsolver_2x2","text":"Solves the 2x2 system\n\n┌                   ┐ ┌    ┐   ┌   ┐\n│ Q + A'F⁻¹F⁻ᵀA  G' │ │ y' │ = │ y │\n│ G                 │ │ w' │   │ w │\n└                   ┘ └    ┘   └   ┘\n\n\n\n\n\n","category":"function"},{"location":"api/#ConicIP.pivot","page":"API Reference","title":"ConicIP.pivot","text":"pivot(kktsolver_2x2)\n\nWrap a 2-by-2 KKT solver into a 3-by-3 solver by pivoting on the third component. The inner solver handles the Schur complement system; pivot reconstructs the full solution.\n\nSee also conicIP for the KKT solver interface specification.\n\n\n\n\n\n","category":"function"},{"location":"api/#ConicIP.Id","page":"API Reference","title":"ConicIP.Id","text":"Id(n)\n\nCreate an n-by-n identity matrix as Diagonal(ones(n)).\n\n\n\n\n\n","category":"function"},{"location":"api/#ConicIP.VecCongurance","page":"API Reference","title":"ConicIP.VecCongurance","text":"VecCongurance(R)\n\nLinear operator representing a congruence transform in vectorized form. The action W * x computes vecm(R' * mat(x) * R).\n\nUsed internally as the Nesterov-Todd scaling matrix for semidefinite cones.\n\n\n\n\n\n","category":"type"},{"location":"api/#ConicIP.mat","page":"API Reference","title":"ConicIP.mat","text":"mat(x)\n\nConvert a vectorized symmetric matrix (scaled lower-triangular form) back to a full symmetric matrix. Inverse of vecm.\n\n\n\n\n\n","category":"function"},{"location":"api/#ConicIP.vecm","page":"API Reference","title":"ConicIP.vecm","text":"vecm(Z)\n\nVectorize a symmetric matrix Z into scaled lower-triangular form. Off-diagonal entries are scaled by √2 so that dot(vecm(X), vecm(Y)) == tr(X*Y). Inverse of mat.\n\n\n\n\n\n","category":"function"},{"location":"api/#ConicIP.imcols","page":"API Reference","title":"ConicIP.imcols","text":"imcols(A, b; ϵ = 1e-10)\n\nRemoves redundant inequalities in a system of equations\n\nAx = b\n\nand checks if the equations are consistent.\n\n\n\n\n\n","category":"function"},{"location":"api/#ConicIP.pivotgen","page":"API Reference","title":"ConicIP.pivotgen","text":"Wrapper around solve2xegen to solve 3x3 systems by pivoting on the third component.\n\n\n\n\n\n","category":"function"},{"location":"api/#ConicIP.placeholder","page":"API Reference","title":"ConicIP.placeholder","text":"Creates a matrix with the same sparsity structure as F\n\n\n\n\n\n","category":"function"},{"location":"api/#ConicIP.identical_sparse_structure","page":"API Reference","title":"ConicIP.identical_sparse_structure","text":"Checks if two sparse matrices have the same sparse structure\n\n\n\n\n\n","category":"function"},{"location":"api/#ConicIP.count_lift","page":"API Reference","title":"ConicIP.count_lift","text":"Estimates for the number of nonzeros of lift(F)\n\n\n\n\n\n","category":"function"},{"location":"api/#ConicIP.count_dense","page":"API Reference","title":"ConicIP.count_dense","text":"Estimates the number of nonzeros of F\n\n\n\n\n\n","category":"function"},{"location":"mathematical_background/#Mathematical-Background","page":"Mathematical Background","title":"Mathematical Background","text":"","category":"section"},{"location":"mathematical_background/#Primal-Problem","page":"Mathematical Background","title":"Primal Problem","text":"ConicIP solves the conic optimization problem\n\nminimize    ½ yᵀQy - cᵀy\nsubject to  Ay - b ∈ K\n            Gy = d\n\nwhere K is a Cartesian product of cones and Q is positive semidefinite.","category":"section"},{"location":"mathematical_background/#Supported-Cones","page":"Mathematical Background","title":"Supported Cones","text":"Nonnegative orthant (\"R\"):\n\nR₊ⁿ = { x ∈ Rⁿ : xᵢ ≥ 0 }\n\nSecond-order cone (\"Q\"):\n\nQⁿ = { (t, x) ∈ R × Rⁿ⁻¹ : ‖x‖₂ ≤ t }\n\nPositive semidefinite cone (\"S\", experimental):\n\nSⁿ₊ = { X ∈ Sⁿ : X ≽ 0 }\n\nMatrices are stored in vectorized form using vecm, which scales off-diagonal entries by √2 to preserve inner products.","category":"section"},{"location":"mathematical_background/#Interior-Point-Method","page":"Mathematical Background","title":"Interior-Point Method","text":"ConicIP implements a homogeneous self-dual interior-point method based on the approach described by Andersen, Dahl, and Vandenberghe (2003). The method solves the primal and dual problems simultaneously and can detect infeasibility and unboundedness without a separate Phase I.","category":"section"},{"location":"mathematical_background/#Nesterov-Todd-Scaling","page":"Mathematical Background","title":"Nesterov-Todd Scaling","text":"At each iteration, the algorithm computes the Nesterov-Todd scaling point w such that the scaling operator F satisfies\n\nF z = F⁻¹ s = λ\n\nwhere z and s are the current primal and dual slack variables, and λ is the scaled point. This symmetric scaling ensures equal treatment of primal and dual and leads to better numerical behavior than primal-only or dual-only scaling.\n\nThe scaling matrix type depends on the cone:\n\nCone Scaling type\nNonnegative orthant Diagonal matrix: F = Diagonal(√(s./z))\nSecond-order cone Rank-2 update of a diagonal (SymWoodbury)\nSemidefinite cone Congruence transform (VecCongurance)","category":"section"},{"location":"mathematical_background/#Predictor-Corrector-Steps","page":"Mathematical Background","title":"Predictor-Corrector Steps","text":"Each iteration consists of two phases:\n\nPredictor (affine) step: Solve the linearized KKT system with the current residuals to compute an affine scaling direction. This step estimates how much the complementarity gap can be reduced.\nCorrector (combined) step: Solve a modified system that includes a centering term σμe and a second-order correction from the predictor step. The centering parameter σ is chosen adaptively based on the predictor step length.","category":"section"},{"location":"mathematical_background/#Convergence-Criteria","page":"Mathematical Background","title":"Convergence Criteria","text":"The solver monitors three residuals:\n\nPrimal feasibility (prFeas): ‖Ay - s - b‖ / (1 + ‖b‖)\nDual feasibility (duFeas): ‖Qy + Gᵀw - Aᵀv - c‖ / (1 + ‖c‖)\nComplementarity (muFeas): sᵀv / (1 + |cᵀy|)\n\nThe solver terminates with status :Optimal when all three residuals fall below the tolerance optTol.","category":"section"},{"location":"mathematical_background/#Infeasibility-Detection","page":"Mathematical Background","title":"Infeasibility Detection","text":"Primal infeasibility (:Infeasible): The solver detects a certificate (w, v) satisfying Gᵀw + Aᵀv ≈ 0 and bᵀv + dᵀw < 0, proving that the primal problem has no feasible point.\n\nDual infeasibility (:Unbounded): The solver detects a certificate y satisfying Ay ≥ 0, Gy ≈ 0, Qy ≈ 0, and cᵀy > 0, proving that the dual problem has no feasible point (equivalently, the primal is unbounded).","category":"section"},{"location":"mathematical_background/#References","page":"Mathematical Background","title":"References","text":"E.D. Andersen, C. Roos, and T. Terlaky. \"On implementing a primal-dual interior-point method for conic quadratic optimization.\" Mathematical Programming, 95(2):249-277, 2003.\nY.E. Nesterov and M.J. Todd. \"Self-scaled barriers and interior-point methods for convex programming.\" Mathematics of Operations Research, 22(1):1-42, 1997.\nL. Vandenberghe and S. Boyd. \"Semidefinite programming.\" SIAM Review, 38(1):49-95, 1996.\nM.S. Andersen, J. Dahl, and L. Vandenberghe. \"CVXOPT: A Python package for convex optimization.\" Available at https://cvxopt.org.","category":"section"},{"location":"tutorials/sdp/#Semidefinite-Programs-(Experimental)","page":"Semidefinite (Experimental)","title":"Semidefinite Programs (Experimental)","text":"warning: Experimental\nSemidefinite cone support in ConicIP is experimental. It works for small problems but has not been extensively tested.\n\nA semidefinite cone constraint requires a symmetric matrix to be positive semidefinite. In ConicIP, matrices are stored in a vectorized form using vecm and mat.","category":"section"},{"location":"tutorials/sdp/#Vectorization-Convention","page":"Semidefinite (Experimental)","title":"Vectorization Convention","text":"The cone specification (\"S\", k) describes a semidefinite cone where k = n(n+1)/2 is the dimension of the vectorized matrix for an n × n symmetric matrix.\n\nvecm(Z) vectorizes a symmetric matrix, scaling off-diagonal entries by √2 so that inner products are preserved: dot(vecm(X), vecm(Y)) == tr(X*Y).\nmat(x) reconstructs the symmetric matrix from its vectorized form.","category":"section"},{"location":"tutorials/sdp/#Example:-Projection-onto-the-PSD-Cone","page":"Semidefinite (Experimental)","title":"Example: Projection onto the PSD Cone","text":"Project the diagonal matrix diag(1, 1, 1, -1, -1, -1) onto the cone of positive semidefinite matrices. The expected result clips the negative eigenvalues to zero: diag(1, 1, 1, 0, 0, 0).\n\nusing ConicIP, SparseArrays, LinearAlgebra\n\n# 6×6 matrix → vectorized dimension k = 6*7/2 = 21\nk = 21\nQ = sparse(1.0I, k, k)\ntarget = diagm(0 => [1.0, 1, 1, -1, -1, -1])\nc = reshape(ConicIP.vecm(target), :, 1)\n\nA = sparse(1.0I, k, k)\nb = zeros(k, 1)\ncone_dims = [(\"S\", k)]\n\nsol = conicIP(Q, c, A, b, cone_dims; verbose=false, optTol=1e-7)\nsol.status\n\nReconstruct the matrix from the solution and check its eigenvalues:\n\nresult = ConicIP.mat(sol.y)\nround.(eigvals(Symmetric(result)), digits=4)\n\nThe negative eigenvalues have been projected to (approximately) zero.","category":"section"},{"location":"tutorials/socp/#Second-Order-Cone-Programs","page":"Second-Order Cone","title":"Second-Order Cone Programs","text":"A second-order cone (SOC) constraint has the form\n\n‖x‖ ≤ t\n\nor equivalently (t, x) ∈ Q, where Q is the second-order (Lorentz) cone. In ConicIP, this is specified as (\"Q\", dim) where dim = 1 + length(x). The first component of the cone block is the scalar bound t.","category":"section"},{"location":"tutorials/socp/#Example:-Projection-onto-the-Unit-Ball","page":"Second-Order Cone","title":"Example: Projection onto the Unit Ball","text":"Project a point onto the unit Euclidean ball {y : ‖y‖ ≤ 1}.\n\nusing ConicIP, SparseArrays, LinearAlgebra\n\nn = 3\nQ = sparse(1.0I, n, n)\na = ones(n, 1)  # point to project\n\n# SOC constraint: (t, y) ∈ Q with t = 1\n# Encode as A*y ≥ b with A = [0...0; I], b = [-1; 0...0]\nA = [spzeros(1, n); sparse(1.0I, n, n)]\nb = [-ones(1, 1); zeros(n, 1)]\ncone_dims = [(\"Q\", n + 1)]\n\nsol = conicIP(Q, Q * a, A, b, cone_dims;\n              verbose=false, optTol=1e-7)\nsol.status\n\nround.(sol.y, digits=4)\n\nThe solution is the normalized vector a / ‖a‖:\n\nround.(a ./ norm(a), digits=4)","category":"section"},{"location":"tutorials/socp/#Example:-Mixed-Cones","page":"Second-Order Cone","title":"Example: Mixed Cones","text":"Combine nonnegative (\"R\") and second-order cone (\"Q\") constraints. Here we minimize a QP subject to both y ≥ 0 and ‖y‖ ≤ 1:\n\nusing ConicIP, SparseArrays, LinearAlgebra, Random\nRandom.seed!(42)\n\nn = 5\nQ = sparse(1.0I, n, n)\nc = randn(n, 1)\n\n# Stack constraints: first n rows are R+ (y ≥ 0),\n# next n+1 rows are SOC (‖y‖ ≤ 1)\nA = [sparse(1.0I, n, n);          # y ≥ 0\n     spzeros(1, n);                # t = 1 (SOC slack)\n     sparse(1.0I, n, n)]           # y components in SOC\nb = [zeros(n, 1);                  # R+ bound\n     -ones(1, 1);                  # t ≥ 1\n     zeros(n, 1)]                  # SOC body\ncone_dims = [(\"R\", n), (\"Q\", n + 1)]\n\nsol = conicIP(Q, c, A, b, cone_dims; verbose=false)\nsol.status\n\nround.(sol.y, digits=4)","category":"section"},{"location":"jump/#JuMP-Integration","page":"JuMP Integration","title":"JuMP Integration","text":"ConicIP provides a MathOptInterface wrapper, so it can be used as a solver backend for JuMP.","category":"section"},{"location":"jump/#Setup","page":"JuMP Integration","title":"Setup","text":"using JuMP, ConicIP\nmodel = Model(ConicIP.Optimizer)","category":"section"},{"location":"jump/#Solver-Options","page":"JuMP Integration","title":"Solver Options","text":"Pass options at construction via an anonymous function:\n\nmodel = Model(() -> ConicIP.Optimizer(verbose=false, optTol=1e-8, maxIters=200))","category":"section"},{"location":"jump/#Example:-Simple-LP","page":"JuMP Integration","title":"Example: Simple LP","text":"using JuMP, ConicIP\n\nmodel = Model(() -> ConicIP.Optimizer(verbose=false, optTol=1e-6))\n\n@variable(model, x[1:2] >= 0)\n@objective(model, Min, x[1] + x[2])\n@constraint(model, x[1] + x[2] >= 1)\n\noptimize!(model)\ntermination_status(model)\n\nround(objective_value(model), digits=6)","category":"section"},{"location":"jump/#Example:-SOC-Constraint","page":"JuMP Integration","title":"Example: SOC Constraint","text":"using JuMP, ConicIP\n\nmodel = Model(() -> ConicIP.Optimizer(verbose=false, optTol=1e-6))\n\n@variable(model, x[1:2])\n@variable(model, t)\n@objective(model, Min, t)\n@constraint(model, x[1] == 1)\n@constraint(model, x[2] == 1)\n@constraint(model, [t; x] in SecondOrderCone())\n\noptimize!(model)\ntermination_status(model)\n\nThe minimum norm is √2:\n\nround(objective_value(model), digits=4)","category":"section"},{"location":"jump/#Example:-Maximization","page":"JuMP Integration","title":"Example: Maximization","text":"using JuMP, ConicIP\n\nmodel = Model(() -> ConicIP.Optimizer(verbose=false, optTol=1e-6))\n\n@variable(model, x[1:2] >= 0)\n@objective(model, Max, x[1] + 2x[2])\n@constraint(model, x[1] + x[2] <= 1)\n\noptimize!(model)\ntermination_status(model)\n\nround(objective_value(model), digits=6)","category":"section"},{"location":"jump/#Supported-Constraints","page":"JuMP Integration","title":"Supported Constraints","text":"Vector sets: Zeros, Nonnegatives, Nonpositives, SecondOrderCone, PositiveSemidefiniteConeTriangle\n\nScalar sets: EqualTo, GreaterThan, LessThan","category":"section"},{"location":"jump/#Limitations","page":"JuMP Integration","title":"Limitations","text":"No quadratic objectives in JuMP form (Q must be zero; use the direct conicIP interface for QPs)\nNo integer variables\nNo indicator or SOS constraints","category":"section"},{"location":"custom_kkt/#Custom-KKT-Solvers","page":"Custom KKT Solvers","title":"Custom KKT Solvers","text":"The interior-point solver can be sped up significantly by exploiting the structure of Q, A, and G. ConicIP supports custom KKT solver callbacks that replace the default factorization at each iteration.","category":"section"},{"location":"custom_kkt/#The-KKT-System","page":"Custom KKT Solvers","title":"The KKT System","text":"At each interior-point iteration, ConicIP solves a 3×3 block system:\n\n┌             ┐ ┌   ┐   ┌   ┐\n│ Q   G'  -A' │ │ a │   │ x │\n│ G           │ │ b │ = │ y │\n│ A       FᵀF │ │ c │   │ z │\n└             ┘ └   ┘   └   ┘\n\nwhere F is a Block diagonal matrix representing the Nesterov-Todd scaling. The block type depends on the cone:\n\nCone Block type Description\n\"R\" Diagonal Diagonal scaling for nonnegative orthant\n\"Q\" SymWoodbury Low-rank-plus-diagonal for second-order cone\n\"S\" VecCongurance Congruence transform for semidefinite cone","category":"section"},{"location":"custom_kkt/#The-kktsolver-Interface","page":"Custom KKT Solvers","title":"The kktsolver Interface","text":"A custom KKT solver is a function with the signature:\n\nfunction my_kktsolver(Q, A, G, cone_dims)\n    # One-time setup (problem structure analysis, symbolic factorization, etc.)\n\n    function solve3x3gen(F, F⁻ᵀ)\n        # Per-iteration setup (F changes each iteration)\n\n        function solve3x3(x, y, z)\n            # Solve the 3×3 system and return (a, b, c)\n            return (a, b, c)\n        end\n        return solve3x3\n    end\n    return solve3x3gen\nend\n\nPass it to the solver via the kktsolver keyword:\n\nsol = conicIP(Q, c, A, b, cone_dims; kktsolver=my_kktsolver)","category":"section"},{"location":"custom_kkt/#Example:-Diagonal-QP","page":"Custom KKT Solvers","title":"Example: Diagonal QP","text":"For the problem minimize ½ xᵀQx - cᵀx subject to x ≥ 0 with a sparse Q, the KKT system simplifies (no equality constraints, so G is empty) to:\n\n┌            ┐ ┌   ┐   ┌   ┐\n│ Q       I  │ │ a │   │ x │\n│ I    -FᵀF  │ │ c │ = │ z │\n└            ┘ └   ┘   └   ┘\n\nSince F is Diagonal for \"R\" cones, (FᵀF)⁻¹ is diagonal. Pivoting on the second block gives (Q + (FᵀF)⁻¹) a = x + (FᵀF)⁻¹ z, which is a diagonal perturbation of Q solvable by Cholesky factorization:\n\nusing ConicIP, SparseArrays, LinearAlgebra, Random\nRandom.seed!(42)\n\nn = 50\nQ = sprandn(n, n, 0.3); Q = Q'Q + 0.1I  # make positive definite\nc = ones(n, 1)\nA = sparse(1.0I, n, n)\nb = zeros(n, 1)\ncone_dims = [(\"R\", n)]\n\nfunction my_kktsolver(Q, A, G, cone_dims)\n    function solve3x3gen(F, F⁻ᵀ)\n        invFᵀF = inv(F'F)\n        QpD = cholesky(Q + spdiagm(0 => (F[1].diag).^(-2)))\n\n        function solve3x3(x, y, z)\n            a = QpD \\ (x + A' * (invFᵀF * z))\n            c = invFᵀF * (z - A * a)\n            b = zeros(0, 1)\n            return (a, b, c)\n        end\n    end\nend\n\nsol = conicIP(Q, c, A, b, cone_dims; kktsolver=my_kktsolver, verbose=false)\nsol.status","category":"section"},{"location":"custom_kkt/#The-pivot-Wrapper","page":"Custom KKT Solvers","title":"The pivot Wrapper","text":"The pattern of reducing a 3×3 system to a 2×2 system by pivoting on the third block is common. The pivot function automates this: it wraps a 2×2 solver into a 3×3 solver.\n\nA 2×2 solver has the signature:\n\nfunction my_2x2_solver(Q, A, G, cone_dims)\n    function solve2x2gen(F, F⁻ᵀ)\n        # Build the Schur complement Q + Aᵀ(FᵀF)⁻¹A\n        function solve2x2(y, w)\n            return (Δy, Δw)\n        end\n        return solve2x2\n    end\n    return solve2x2gen\nend\n\nThen pivot(my_2x2_solver) produces a valid 3×3 solver.\n\nHere is the same diagonal QP example using pivot:\n\nfunction my_2x2_solver(Q, A, G, cone_dims)\n    function solve2x2gen(F, F⁻ᵀ)\n        QpD = cholesky(Q + spdiagm(0 => (F[1].diag).^(-2)))\n        return (y, w) -> (QpD \\ y, zeros(0, 1))\n    end\nend\n\nsol2 = conicIP(Q, c, A, b, cone_dims;\n               kktsolver=pivot(my_2x2_solver), verbose=false)\nsol2.status","category":"section"},{"location":"custom_kkt/#Built-in-Solvers","page":"Custom KKT Solvers","title":"Built-in Solvers","text":"ConicIP provides three built-in KKT solvers:\n\nkktsolver_qr – QR-based solver (default), works for all problem types\nkktsolver_sparse – sparse LU solver, automatically chooses between lifted and dense formulations\nkktsolver_2x2 – 2×2 sparse LU solver (use with pivot)","category":"section"},{"location":"tutorials/getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"tutorials/getting_started/#Problem-Formulation","page":"Getting Started","title":"Problem Formulation","text":"ConicIP solves optimization problems of the form\n\nminimize    ½ yᵀQy - cᵀy\nsubject to  Ay ≥_K b\n            Gy  = d\n\nwhere ≥_K denotes a generalized inequality with respect to a cone K.","category":"section"},{"location":"tutorials/getting_started/#Arguments","page":"Getting Started","title":"Arguments","text":"Q – positive semidefinite Hessian matrix (n × n). Set to zero for linear programs.\nc – linear objective term (n × 1 matrix, not a vector)\nA – inequality constraint matrix (m × n)\nb – inequality right-hand side (m × 1 matrix)\ncone_dims – cone specification for the inequality constraints\nG – equality constraint matrix (p × n), optional\nd – equality right-hand side (p × 1 matrix), optional\n\nnote: Column matrices\nConicIP expects c, b, and d to be n × 1 matrices (created with reshape or literal [1.0; 2.0;; ]), not Julia Vectors. Use reshape(v, :, 1) to convert a vector v.","category":"section"},{"location":"tutorials/getting_started/#Cone-Specification","page":"Getting Started","title":"Cone Specification","text":"The cone_dims argument is a vector of (type, dimension) tuples describing how the rows of A and b are partitioned into cone constraints:\n\n(\"R\", n) – nonnegative orthant: the first n rows satisfy Ay - b ≥ 0\n(\"Q\", m) – second-order cone: the next m rows satisfy ‖(Ay-b)[2:end]‖ ≤ (Ay-b)[1]\n(\"S\", k) – semidefinite cone (experimental): the next k rows represent a vectorized symmetric matrix that must be positive semidefinite, where k = n(n+1)/2\n\nFor example, [(\"R\", 3), (\"Q\", 5)] means the first 3 rows of Ay ≥ b are nonnegative constraints, and the next 5 rows form a second-order cone constraint.","category":"section"},{"location":"tutorials/getting_started/#Solution","page":"Getting Started","title":"Solution","text":"The solver returns a Solution struct with the following key fields:\n\nsol.y – primal variables\nsol.w – dual variables for equality constraints\nsol.v – dual variables for inequality constraints\nsol.status – :Optimal, :Infeasible, :Unbounded, :Abandoned, or :Error\nsol.pobj, sol.dobj – primal and dual objective values\nsol.prFeas, sol.duFeas, sol.muFeas – feasibility residuals","category":"section"},{"location":"tutorials/getting_started/#Example:-Box-Constrained-QP","page":"Getting Started","title":"Example: Box-Constrained QP","text":"Solve a box-constrained quadratic program: minimize ½ yᵀQy - cᵀy subject to 0 ≤ y ≤ 1.\n\nusing ConicIP, SparseArrays, LinearAlgebra, Random\nRandom.seed!(42)\n\nn = 10\nQ = sparse(Diagonal(rand(n) .+ 0.1))\nc = randn(n, 1)\n\n# Encode 0 ≤ y ≤ 1 as [I; -I] y ≥ [0; -1]\nA = sparse([I(n); -I(n)])\nb = [zeros(n, 1); -ones(n, 1)]\ncone_dims = [(\"R\", 2n)]\n\nsol = conicIP(Q, c, A, b, cone_dims; verbose=false)\nsol.status\n\nThe primal solution:\n\nround.(sol.y, digits=4)\n\nThe convergence residuals confirm the solve quality:\n\n(prFeas=sol.prFeas, duFeas=sol.duFeas, muFeas=sol.muFeas)","category":"section"},{"location":"#ConicIP.jl","page":"Home","title":"ConicIP.jl","text":"ConicIP.jl is a pure-Julia conic interior-point solver for optimization problems with linear, second-order cone, and (experimental) semidefinite constraints.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Pure Julia – no external solver dependencies\nJuMP / MathOptInterface integration – use as Model(ConicIP.Optimizer)\nCustom KKT solver callbacks – exploit problem structure for speed\nNesterov-Todd scaling – symmetric primal-dual scaling\nInfeasibility and unboundedness detection – returns certificates","category":"section"},{"location":"#Supported-Problem-Types","page":"Home","title":"Supported Problem Types","text":"Linear programs (LP)\nQuadratic programs (QP)\nSecond-order cone programs (SOCP)\nSemidefinite programs (SDP) – experimental","category":"section"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"using ConicIP, SparseArrays, LinearAlgebra, Random\nRandom.seed!(42)\n\n# Box-constrained QP: minimize ½ y'Qy - c'y subject to 0 ≤ y ≤ 1\nn = 5\nQ = sparse(Diagonal(rand(n) .+ 0.1))\nc = randn(n, 1)\n\n# Constraints: [I; -I] y >= [0; -1] (i.e., y >= 0 and y <= 1)\nA = sparse([I(n); -I(n)])\nb = [zeros(n, 1); -ones(n, 1)]\ncone_dims = [(\"R\", 2n)]\n\nsol = conicIP(Q, c, A, b, cone_dims; verbose=false)\nsol.status\n\nround.(sol.y, digits=4)","category":"section"}]
}
